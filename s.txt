<<<<<<< HEAD
/*Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await dotenv.load(fileName: ".env");

  AndroidOptions getAndroidOptions() => const AndroidOptions(
    encryptedSharedPreferences: true,
  );

  final secureStorage = FlutterSecureStorage(aOptions: getAndroidOptions());

  final authLocalDataSource = AuthLocalDataSourceImpl(storage: secureStorage);
  final authRemoteDataSource = AuthRemoteDataSourceImpl();
  final userRemoteDataSource = UserRemoteDataSourceImpl();
  final planetDataSource = PlanetRemoteDataSourceImpl();
  
  final authRepository = AuthRepositoryImpl(
    remoteDataSource: authRemoteDataSource,
    localDataSource: authLocalDataSource,
  );
  final userRepository = UserRepositoryImpl(remoteDataSource: userRemoteDataSource, localDataSource: authLocalDataSource);
  final planetRepository = PlanetRepositoryImpl(remoteDataSource: planetDataSource);

  final createUserUseCase = CreateuserUsecase(authRepository);
  final verifyUserUseCase = VerifyuserUsecase(authRepository);
  final getAllPlanetsUseCase = GetAllPlanetsUseCase(planetRepository);
  final getPlanetOfDayUseCase = GetPlanetOfDayUseCase(planetRepository);
  final getProfileUseCase = GetProfileUseCase(userRepository);
  final deleteAccountUseCase = DeleteAccountUseCase(userRepository);
  final logoutUseCase = LogoutUseCase(userRepository); 
  
  runApp(
    MainApp(
      createUserUseCase: createUserUseCase,
      verifyUserUseCase: verifyUserUseCase,
      getAllPlanetsUseCase: getAllPlanetsUseCase,
      getPlanetOfDayUseCase: getPlanetOfDayUseCase,
      getProfileUseCase: getProfileUseCase,
      deleteAccountUseCase: deleteAccountUseCase,
      logoutUseCase: logoutUseCase,
    ),
  );
}*/


class MainApp extends StatelessWidget {
  final CreateuserUsecase createUserUseCase;
  final VerifyuserUsecase verifyUserUseCase;
  final GetAllPlanetsUseCase getAllPlanetsUseCase;
  final GetPlanetOfDayUseCase getPlanetOfDayUseCase;
  final GetProfileUseCase getProfileUseCase;
  final DeleteAccountUseCase deleteAccountUseCase;
  final LogoutUseCase logoutUseCase;

  const MainApp({
    super.key, 
    required this.createUserUseCase,
    required this.verifyUserUseCase,
    required this.getAllPlanetsUseCase,
    required this.getPlanetOfDayUseCase,
    required this.getProfileUseCase,
    required this.deleteAccountUseCase,
    required this.logoutUseCase
  });

  @override
  Widget build(BuildContext context) {
    return MultiProvider(
      providers: [
        ChangeNotifierProvider(
          create: (_) => RegistreProvider(createUserUseCase),
        ),
        ChangeNotifierProvider(
          create: (_) => LoginProvider(verifyUserUseCase),
        ),
        ChangeNotifierProvider(
          create: (_) => HomeProvider(
            getAllPlanetsUseCase: getAllPlanetsUseCase,
            getPlanetOfDayUseCase: getPlanetOfDayUseCase,
          ),
        ),
        ChangeNotifierProvider(
          create: (_) => ProfileProvider(
            getProfileUseCase: getProfileUseCase, 
            logoutUseCase: logoutUseCase, 
            deleteAccountUseCase: deleteAccountUseCase
          ),
        ),
      ],
      child: MaterialApp.router(
        debugShowCheckedModeBanner: false,
        title: 'Astronom√≠a Registro',
        theme: ThemeData.dark().copyWith(
          scaffoldBackgroundColor: Color(0xFF101622),
          primaryColor: Color(0xFF135bec),
          colorScheme: ColorScheme.dark(
            primary: Color(0xFF135bec),
            secondary: Color(0xFF135bec),
          ),
        ),
        routerConfig: AppRouter.router,
      ),
    );
  }
}


profile Widget
_buildDropdownSimulation(
          value: "Ori√≥n",
          icon: Icons.star_outline,
        ),

Widget _buildDropdownSimulation({
    required String value,
    required IconData icon,
  }) {
    return Container(
      decoration: BoxDecoration(
        color: Color(0xFF1f293b), // input-dark
        borderRadius: BorderRadius.circular(12),
      ),
      padding: EdgeInsets.symmetric(horizontal: 16, vertical: 4),
      child: Row(
        children: [
          Icon(icon, color: Colors.grey, size: 22),
          SizedBox(width: 12),
          Expanded(
            child: DropdownButtonHideUnderline(
              child: DropdownButton<String>(
                value: value,
                dropdownColor: Color(0xFF1f293b),
                icon: Icon(Icons.expand_more, color: Colors.grey),
                style: TextStyle(color: Colors.white, fontSize: 16),
                onChanged: (newValue) {},
                items: AppResources.slected.map<DropdownMenuItem<String>>((String value) {
                  return DropdownMenuItem<String>(
                    value: value,
                    child: Text(value),
                  );
                }).toList(),
              ),
            ),
          ),
        ],
      ),
    );
  }


  ahora como puedo hacer la parte de actualizar datos del cliente en la app, los datos que se envian pueden ser nulos, osea que no todos se actualizaran
routerUser.patch(
    "/update/:id", 
    (req: Request, res: Response) => updateUserController.run(req, res)
);

me base en crear usuario por lo que puedo tener errores
import 'package:app_rest/features/user/domain/entities/user.dart' show User;
import 'package:app_rest/features/user/domain/repository/user_repository.dart';

class EditProfileUseCase {
  final UserRepository repository;

  EditProfileUseCase(this.repository);

  Future<bool>call(User user) async{
    return await repository.editProfile(user);
  }
}

import 'package:app_rest/features/user/domain/entities/user.dart';

abstract class UserRepository {
  Future<User> getUserProfile();
  Future<bool> editProfile(User user);
  Future<void> deleteAccount();
  Future<void> logout();
}

class User {
  final String? id;
  final String name;
  final String email;
  final String image;
  final List<String> tags;
  final String constellation;

  const User({
    this.id,
    required this.name,
    required this.email,
    required this.image,
    required this.tags,
    required this.constellation
  });
}

import 'package:app_rest/features/auth/data/datasources/auth_local_data_source.dart';
import 'package:app_rest/features/user/data/datasource/user_remote_data_source.dart';
import 'package:app_rest/features/user/data/model/user_model.dart';
import 'package:app_rest/features/user/domain/entities/user.dart' show User;

import '../../domain/repository/user_repository.dart';

class UserRepositoryImpl implements UserRepository {
  final UserRemoteDataSource remoteDataSource;
  final AuthLocalDataSource localDataSource;

  UserRepositoryImpl({
    required this.remoteDataSource,
    required this.localDataSource,
  });

  Future<String> _getUserIdOrThrow() async {
    final id = await localDataSource.getUserId();
    if (id == null) throw Exception("Usuario no autenticado");
    return id;
  }

  @override
  Future<User> getUserProfile() async {
    final id = await _getUserIdOrThrow();
    return await remoteDataSource.getUser(id);
  }

  Future<bool> editProfile(User user) async{
    final userModel = UserModel.fromJson(json) -> me falta no se si esta bien, todavia no comprendo como enviar datos con la estructura movil de cleaning arquitecture
  }

  //otros metodos ...
}

import '../../domain/entities/user.dart';

class UserModel extends User {
  const UserModel({
    required super.id,
    required super.name,
    required super.email, 
    required super.image, 
    required super.tags, 
    required super.constellation,
  });

  factory UserModel.fromJson(Map<String, dynamic> json) {
    return UserModel(
      id: json['id']?.toString() ?? '',
      name: json['name'] ?? '',
      email: json['email'] ?? '', 
      image: json['image'] ?? '', 
      tags: (json['tag'] as List<dynamic>?) ?.map((e) => e.toString()).toList() ?? [],
      constellation: json['constellation'] ?? '',
    );
  }

  factory UserModel.fromEntity(User user) { -> aqui no se que hace esto solo me vase en use create que ya tenia
    return UserModel(
      name: user.name,
      email: user.email, 
      id: '', 
      image: '', 
      tags: [], 
      constellation: '',
    );
  }
}

import 'dart:convert';

import 'package:app_rest/core/network/http_client.dart';
import 'package:app_rest/features/user/data/model/user_model.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'package:http/http.dart' as http;

abstract class UserRemoteDataSource {
  Future<UserModel> getUser(String id);
  Future<void> deleteUser(String id);
}

class UserRemoteDataSourceImpl implements UserRemoteDataSource {
  final http.Client client;
  final String apiUrl = dotenv.env['API_URL'] ?? '';

  UserRemoteDataSourceImpl({http.Client? client}) : client = client ?? HttpClient().client;

  @override
  Future<UserModel> getUser(String id) async {
    print("üîç Buscando usuario con ID: '$id'");
    final url = Uri.parse('$apiUrl/api/v1/user/get/$id'); 
    print("üåê URL Generada: $url");

    try {
      final response = await client.get(url);
      
      print("üì° Respuesta C√≥digo: ${response.statusCode}");
      print("üì¶ Respuesta Body: ${response.body}");

      if (response.statusCode == 200) {
        final Map<String, dynamic> data = jsonDecode(response.body);
        return UserModel.fromJson(data);
      } else {
        throw Exception('Error API: ${response.statusCode}');
      }
    } catch (e) {
      print("‚ùå Error en petici√≥n: $e");
      rethrow;
    }
  }

  @override
  Future<void> deleteUser(String id) async {
    final url = Uri.parse('$apiUrl/api/v1/user/delete/$id');
    
    final response = await client.delete(url);

    if (response.statusCode != 200 && response.statusCode != 204) {
       throw Exception('Error al eliminar cuenta');
    }
  }
}
=======
Si se utiliza este proyecto procura dar credito que me costo hacerlo >:v
>>>>>>> 49099aa41470a86f596d6b175cd44f956e9341b3
